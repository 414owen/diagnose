{-# LANGUAGE Safe #-}

-- |
-- Module      : Error.Diagnose
-- Description : A quick tutorial on the use of this library.
-- Copyright   : (c) Mesabloo and contributors, 2021-
-- License     : BSD3
-- Stability   : experimental
-- Portability : Portable
--
-- This module is the main entry point of this library and is the only one which is required to be imported when using
-- this library because it already exports everything needed.
module Error.Diagnose
  ( -- $header

    -- * How to use this module
    -- $usage

    -- ** Generating a report
    -- $generate_report

    -- ** Creating diagnostics from reports
    -- $create_diagnostic

    -- *** Pretty-printing a diagnostic onto a file 'System.IO.Handle'
    -- $diagnostic_pretty

    -- *** Pretty-printing a diagnostic as a document
    -- $diagnostic_to_doc

    -- *** Exporting a diagnostic to JSON
    -- $diagnostic_json

    -- ** Compatibility layers for popular parsing libraries
    -- $compatibility_layers

    -- *** megaparsec >= 9.0.0 ("Error.Diagnose.Compat.Megaparsec")
    -- $compatibility_megaparsec

    -- *** parsec >= 3.1.14.0 ("Error.Diagnose.Compat.Parsec")
    -- $compatibility_parsec

    -- *** Common errors
    -- $compatibility_errors

    -- ** Writing layouts and styles
    -- $layout_and_styles

    -- * Re-exports
    module Export,
  )
where

import Error.Diagnose.Diagnostic as Export
import Error.Diagnose.Layout as Export
import Error.Diagnose.Position as Export
import Error.Diagnose.Pretty as Export
import Error.Diagnose.Report as Export
import Error.Diagnose.Style as Export

-- $header
--
--   This module exports all the needed data types to use this library.
--   It should be sufficient to only @import "Error.Diagnose"@.

-- $usage
--
--   This library is intended to provide a very simple way of creating beautiful errors, by exposing
--   a small yet simple API to the user.
--
--   The basic idea is that a diagnostic is a collection of reports (which embody errors or warnings) along
--   with the files which can be referenced in those reports.

-- $generate_report
--
--   A report contains:
--
--   - A message, to be shown at the top (with an optional error code);
--
--   - A list of located markers, used to underline parts of the source code and to emphasize it with a message;
--
--   - A list of hints, shown at the very bottom;
--
--   __Note__: The message type contained in a report is abstracted by a type variable.
--             In order to render the report, the message must also be able to be rendered in some way
--             (that we'll see later).
--
--   This library allows defining reports using the 'Report' constructor, which has the following type:
--
--   > Report ::
--   >   Severity ->                   -- (1)
--   >   Maybe msg ->                  -- (2)
--   >   msg ->                        -- (3)
--   >   [Marker msg 'MainMarker] ->   -- (4)
--   >   [Note msg] ->                 -- (5)
--   >   Report msg
--
--   1. The 'Error.Diagnose.Report.Severity' tells whether the report is for an 'Error.Diagnose.Report.Error', a 'Error.Diagnose.Report.Warning' or a 'Error.Diagnose.Report.Critical' error;
--
--   2. This parameter is an optional error code to be shown along with the report.
--      This can be useful if you are maintaining a more thorough documentation on each error, explaining what they are and why they exist;
--
--   3. This is the error message to be shown in the report.
--      In general, this is short and concise;
--
--   4. This list may only contain 'Error.Diagnose.Report.Primary', 'Error.Diagnose.Report.Secondary' or 'Error.Diagnose.Report.Blank' markers.
--      They are described a bit later on;
--
--   5. And finally, a list of notes or hints for example to include links to the documentation, potential fixes (along with adding source code!), etc.
--
--   A very simple example is:
--
--   > exampleReport :: Report String
--   > exampleReport =
--   >   Report
--   >     -- vv Report severity
--   >     Error
--   >     -- vv  OPTIONAL ERROR CODE
--   >     Nothing
--   >     -- vv  ERROR MESSAGE
--   >     "This is my first error report"
--   >     -- vv  MARKERS
--   >     [ Primary (Range (1, 3) (1, 8) "some_test.txt") $ Just "Some text under the marker") ]
--   >     -- vv  HINTS
--   >     []
--
--   In general, 'SourceRange's are returned by either a lexer or a parser, so that you never have to construct them
--   directly in the code.
--
--   __Note__: If using any parser library, you will have to convert from the internal positioning system to a 'SourceRange'
--             to be able to use this library.
--
--   Markers put in the report can be one of:
--
--   - A 'Error.Diagnose.Report.Primary' marker, which is the primary marker of the report.
--     While it is allowed to have multiple of these inside one report, it is encouraged not to, because the position at the top of
--     the report will only be the one of the /first/ 'Error.Diagnose.Report.Primary' marker, and because the resulting report may be harder to understand (depending on the layout and style chosen).
--
--   - A 'Error.Diagnose.Report.Secondary' marker contains additional information\/provides context to the error\/warning report.
--     For example, it may underline where a given variable @x@ is bound to emphasize it.
--
--   - A 'Error.Diagnose.Report.Blank' marker is useful only to output additional lines of code in the report.
--     This marker should not be output.

-- $create_diagnostic
--
--   To create a new diagnostic, you need to use its 'Data.Default.Default' instance (which exposes a 'def' function, returning a new empty 'Diagnostic').
--   Once the 'Diagnostic' is created, you can use either 'addReport' (which takes a 'Diagnostic' and a 'Report', abstract by the same message type,
--   and returns a 'Diagnostic') to insert a new report inside the diagnostic, or 'addFile' (which takes a 'Diagnostic', a 'FilePath' and a @['String']@,
--   and returns a 'Diagnostic') to insert a new file reference in the diagnostic.
--
--   You can then either pretty-print the diagnostic obtained (which requires all messages to be instances of the 'Prettyprinter.Pretty')
--   -- directly onto a file handle or as a plain 'Prettyprinter.Doc'ument --
--   or export it to a lazy JSON 'Data.Bytestring.Lazy.ByteString' (e.g. in a LSP context).

-- $diagnostic_pretty
--
--   'Diagnostic's can be output to any 'System.IO.Handle' using the 'printDiagnostic' function.
--   This function takes several parameters:
--
--   - The 'System.IO.Handle' onto which to output the 'Diagnostic'.
--     It __must__ be a 'System.IO.Handle' capable of outputting data.
--
--   - A 'Bool' used to indicate whether you want to output the 'Diagnostic' with unicode characters, or simple ASCII characters.
--
--         Here are two examples of the same diagnostic, the first output with unicode characters, and the second output with ASCII characters:
--
--         > [error]: Error with one marker in bounds
--         >      ╭──▶ test.zc@1:25-1:30
--         >      │
--         >    1 │ let id<a>(x : a) : a := x + 1
--         >      •                         ┬────
--         >      •                         ╰╸ Required here
--         >      │
--         > ─────╯
--
--         > [error]: Error with one marker in bounds
--         >      +--> test.zc@1:25-1:30
--         >      |
--         >    1 | let id<a>(x : a) : a := x + 1
--         >      :                         ^----
--         >      :                         `- Required here
--         >      |
--         > -----+
--
--   - A 'Bool' set to 'False' if you don't want colors in the end result.
--
--   - A 'Int' describing the number of spaces with which to output a TAB character.
--
--   - The 'Style' describing colors of the report.
--     See the module "Error.Diagnose.Style" for how to define new styles.
--
--   - The 'Layout' chosen for the rendering process.
--     The example above uses the ariadne-inspired layout available from the @diagnose-ariadne@ package.
--
--   - And finally the 'Diagnostic' to output.

-- $diagnostic_to_doc
--
-- 'Diagnostic's can be “output” (at least ready to be rendered) to a 'Prettyprinter.Doc' using 'prettyDiagnostic', which allows it to be easily added to other 'Prettyprinter.Doc' outputs.
-- This makes it easy to customize the error messages further (though not the internal parts, only adding to it).
-- As a 'Prettyprinter.Doc', there is also the possibility of altering internal annotations (styles) much easier (although this is already possible when printing the diagnostic).
--
-- The arguments of the function mostly follow the ones from 'printDiagnostic'.

-- $diagnostic_json
--
--   'Diagnostic's can be exported to a JSON record of the following type, using the 'diagnosticToJson' function:
--
--   > Position :
--   >   { "beginning": { line: int, column: int }
--   >   , "end": { line: int, column: int }
--   >   , "file": string
--   >   }
--
--   > Marker :
--   >     { "kind": "primary", "position": Position, "message": T? }
--   >   | { "kind": "secondary", "position": Position, "message": T? }
--   >   | { "kind": "blank", "position": Position }
--   >   | { "kind": "add", "position": Position, "code": string }
--   >   | { "kind": "remove", "position": Position }
--
--   > Note :
--   >   { "kind": "note" | "hint", "message": T, "markers": Marker? }
--
--   > Diagnostic :
--   >   { "files": [{ "name": string, "content": [string] }]
--   >   , "reports":
--   >     [{ "kind": "error" | "warning" | "critical"
--   >      , "code": T?
--   >      , "message": T
--   >      , "markers": [Marker]
--   >      , "notes": [Note]
--   >      }]
--   >   }
--
--   This is particularly useful in the context of a LSP server, where outputting or parsing a raw error yields strange results or is unnecessarily complicated.
--
--   Please note that this requires the flag @diagnose:json@ to be enabled (it is disabled by default in order not to include @aeson@, which is a heavy library).

-- $compatibility_layers
--
--   There are many parsing libraries available in the Haskell ecosystem, each coming with its own way of handling errors.
--   Eventually, one needs to be able to map errors from these libraries to 'Diagnostic's, without having to include additional code for doing so.
--   This is where compatibility layers come in handy.
--
--   As of now, there are compatibility layers for these libraries:

-- $compatibility_megaparsec
--
--   This needs the flag @diagnose:megaparsec-compat@ to be enabled.
--
--   Using the compatibility layer is very easy, as it is designed to be as simple as possible.
--   One simply needs to convert the 'Text.Megaparsec.ParseErrorBundle' which is returned by running a parser into a 'Diagnostic' by using 'Error.Diagnose.Compat.Megaparsec.diagnosticFromBundle'.
--   Several wrappers are included for easy creation of kinds (error, warning) of diagnostics.
--
--   __Note:__ the returned diagnostic does not include file contents, which needs to be added manually afterwards.
--
--   As a quick example:
--
--   > import qualified Text.Megaparsec as MP
--   > import qualified Text.Megaparsec.Char as MP
--   > import qualified Text.Megaparsec.Char.Lexer as MP
--   >
--   > let filename = "<interactive>"
--   >     content  = "00000a2223266"
--   >
--   > let myParser = MP.some MP.decimal <* MP.eof
--   >
--   > let res      = MP.runParser myParser filename content
--   >
--   > case res of
--   >   Left bundle ->
--   >     let diag  = errorDiagnosticFromBundle Nothing "Parse error on input" Nothing bundle
--   >            --   Creates a new diagnostic with no default hints from the bundle returned by megaparsec
--   >         diag' = addFile diag filename content
--   >            --   Add the file used when parsing with the same filename given to 'MP.runParser'
--   >     in printDiagnostic stderr True True 4 ariadneStyle ariadneLayout diag'
--   >   Right res   -> print res
--
--   This example will return the following error message (assuming default instances for @'Error.Diagnose.Compat.Megaparsec.HasHints' 'Data.Void.Void' msg@):
--
--   > [error]: Parse error on input
--   >      ╭──▶ <interactive>@1:6-1:7
--   >      │
--   >    1 │ 00000a2223266
--   >      •      ┬
--   >      •      ├╸ unexpected 'a'
--   >      •      ╰╸ expecting digit, end of input, or integer
--   > ─────╯

-- $compatibility_parsec
--
--   This needs the flag @diagnose:parsec-compat@ to be enabled.
--
--   This compatibility layer allows easily converting 'Text.Parsec.Error.ParseError's into a single-report diagnostic containing all available information such
--   as unexpected/expected tokens or error messages.
--   The function 'Error.Diagnose.Compat.Parsec.diagnosticFromParseError' is used to perform the conversion between a 'Text.Parsec.Error.ParseError' and a 'Diagnostic'.
--
--   __Note:__ the returned diagnostic does not include file contents, which needs to be added manually afterwards.
--
--   Quick example:
--
--   > import qualified Text.Parsec as P
--   >
--   > let filename = "<interactive>"
--   >     content  = "00000a2223266"
--   >
--   > let myParser = P.many1 P.digit <* P.eof
--   >
--   > let res      = P.parse myParser filename content
--   >
--   > case res of
--   >   Left error ->
--   >     let diag  = errorDiagnosticFromParseError Nothing "Parse error on input" Nothing error
--   >            --   Creates a new diagnostic with no default hints from the bundle returned by megaparsec
--   >         diag' = addFile diag filename content
--   >            --   Add the file used when parsing with the same filename given to 'MP.runParser'
--   >     in printDiagnostic stderr True True 4 ariadneStyle ariadneLayout diag'
--   >   Right res  -> print res
--
--   This will output the following error on @stderr@:
--
--   > [error]: Parse error on input
--   >      ╭──▶ <interactive>@1:6-1:7
--   >      │
--   >    1 │ 00000a2223266
--   >      •      ┬
--   >      •      ├╸ unexpected 'a'
--   >      •      ╰╸ expecting any of digit, end of input
--   > ─────╯

-- $compatibility_errors
--
--   - @No instance for (HasHints ??? msg) arising from a use of ‘errorDiagnosticFromBundle’@ (@???@ is any type, depending on your parser's custom error type):
--
--       The typeclass 'Error.Diagnose.Compat.Megaparsec.HasHints' does not have any default instances, because treatments of custom errors is highly dependent on who is using the library.
--       As such, you will need to create orphan instances for your parser's error type.
--
--       Note that the message type @msg@ can be left abstract if the implements of 'Error.Diagnose.Compat.Hints.hints' is @hints _ = mempty@.

-- $layout_and_styles
--
-- The @diagnose@ library is very flexible, and does not include a default style to use for rendering errors.
-- As such, multiple packages are available, defining new layout rules and styles.
-- Here is a non-exhaustive list:
--
-- - @diagnose-ariadne@ takes inspiration from the [ariadne](https://github.com/zesterer/ariadne) Rust library.
--   This was the original layout by default, but has been moved to its own package.
--   All the errors earlier are rendered using this style.
--
-- - @diagnose-gcc@ outputs errors in a similar fashion as the GCC toolchain.
--
-- - @diagnose-typescript@ renders errors similarly to some TypeScript compilers.
--
-- - @diagnose-codespan-reporting@ is inspired by the [codespan-reporting](https://github.com/brendanzab/codespan) Rust crate.
--
-- However, if none of these layouts fit your needs, you can also simply create your own!
--
-- A 'Layout' is a function from a 'Bool', an 'Int' and a 'Diagnostic' to a 'Prettyprinter.Doc'.
--
-- - The 'Bool' argument indicates whether we want the output to have Unicode characters or not.
--   You may fully ignore this argument and always output in either Unicode or ASCII.
--
-- - The 'Int' argument gives the amount of spaces that a TAB character must span when rendering.
--   It is better not to discard it, in order not to confuse the end user (or yourself!).
--
-- - The 'Diagnostic' argument is the diagnostic to render.
--
-- Note that there are a few restrictions on the types of arguments:
--
-- - The @msg@ type in the 'Diagnostic' must be pretty-printable (i.e. there must be an instance of @Pretty msg@);
--
-- - The @ann@ type, which describes the annotations in the 'Prettyprinter.Doc', must be an instance of 'IsAnnotation'.
--   'IsAnnotation' is a typeclass which defines that a specific annotation type can be used to produce colors.
--   See its documentation for more information.
--
--     Together with the 'Prettyprinter.reAnnotate' function, this defines a 'Style'.
--
-- Also, just for layout writers, there are some utility functions defined in the module "Error.Diagnose.Utils"
--   (for example to fetch lines of code with colors).
